
# Content
# 1.  [exception](./exception.md)
# 2.   [springException](./springException.md)

### Summary
#### 예외 계층
![load failed](/spring/static/png/ExceptionLayer.png)

#### 예외의 기본 규칙
- 예외는 잡아서 처리하거나, 처리할 수 없으면 밖으로 던져야한다.

#### 체크 예외와 언체크 예외
- 둘의 차이는 던질때 어떻게 할 것인가이다.

**체크 예외**: 예외를 잡아서 처리하지 않으면 항상 `throws`레 던지는 예외를 선언해야한다.
**언체크 예외**: 예외를 잡고 처리하지 않아도 `throws`를 생략할 수 있다.

#### 체크 예외 활용
- 기본적으로 언체크(런타임)예외를 사용하자.
- 체크 예외는 비즈니스 로직상 의도적으로 던지는 예외에 사용하자

- 문제점
	- 어짜피 처리할 수 없는 예외(복구 불가능한)인데 **예외에 의존**해야함.
#### 언체크 예외 활용
- 서비스나 컨트롤러에서 잡고싶으면 잡고 잡기 싫으면 안잡아도 된다.
- 구현 기술이 바뀐다 하더라도 공통에서만 언체크 예외를 해결하면 된다.

**이전의 에러를 새로운 에러에 넣어 주어야한다**
- 넣지 않으면 기존의 스택트레이스가 없어진다.

## SpringException

#### 기존 예외의 문제점
1. 인터페이스를 만들지 못했다
	- 특정 기술에 의존하는 예외(`SQLException`)가 있어 인터페이스를 만들지 못했다.
2. 서비스 계층이 특정 기술의 예외에 의존하고 있다.
	- 항상 `throws SQLException`같은 예외에 의존해야한다.

#### 해결 방법
1. 언체크드 예외를 이용하여 `throws`를 사용하지 않는다.
	- 언체크드 예외를 사용하지 않으면 앞선 문제점 1, 2를 모두 해결할 수 있었다.
	-  서비스 계층에서 복구가 가능한 예외일 경우 다시 특정 기술의 예외에 의존해야한다.
2. Spring에서 제공하는 `Exception`을 활용하자
	- 스프링에서 제공하는 예외를 사용할 경우 서비스 계층이 스프링에 의존해야하지만 어떤 디비를 쓰던 스프링에서 제공하는 예외를 던지므로 트레이드오프가 있지만 깔끔하게 처리할 수 있다.
	- 데이터베이스마다 오류 코드가 각각 다 다르다.
		- 코드가 굉장히 복잡해질 것이다.
3. `Translator`를 활용하자
	- 각 데이터 베이스의 에러코드를 스프링이 변환하여 스프링에서 제공하는 `Exception`으로 변환해준다.
		- 어떤 DB를 사용하던간에 일관성 있는 예외를 손쉽게 매치시킬 수 있다.